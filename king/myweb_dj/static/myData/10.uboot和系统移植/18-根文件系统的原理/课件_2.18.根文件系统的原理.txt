《2.uboot和系统移植-第18部分-2.18.根文件系统的原理》

--------------------------------------------------------
			欢迎访问《朱老师物联网大讲堂》官方网站
					www.zhulaoshi.org
				   以获取本课程更多信息
--------------------------------------------------------
第一部分、章节目录
2.18.1.根文件系统概述
2.18.2.根文件系统的形式
2.18.3.自己制作ext3格式的根文件系统
2.18.4.nfs方式启动自制简易文件夹形式的rootfs
2.18.5.到底什么是linuxrc
2.18.6.rootfs中还应该有什么
2.18.7.VFS简介


第二部分、章节介绍
2.18.1.根文件系统概述
	本节课对根文件系统进行概述，主要讲述了根文件系统存在的意义和根文件系统的物理本质。
2.18.2.根文件系统的形式
	本节课探讨根文件系统的两种形态：烧录镜像形式和文件夹形式，试图从这个出发点让大家加深对根文件系统的本质的理解。
2.18.3.自己制作ext2格式的根文件系统
	本节将自己制作一个最简易的ext2格式的rootfs，然后fastboot烧写启动去挂载执行，通过这个小实验让大家消除对rootfs的陌生感。
2.18.4.nfs方式启动自制简易文件夹形式的rootfs
	本节将配置内核支持nfs启动挂载rootfs，并且自己做一个简单的文件夹作为根文件系统，其中涉及到nfs服务器搭建等细节问题。
2.18.5.到底什么是linuxrc
	本节对linuxrc文件的本质进行探索，引出busybox，让大家对根文件系统的重点busybox的意义有所了解。
2.18.6.rootfs中还应该有什么
	本节继续对rootfs进行扩展，讲解了rootfs中还应该有，或者说还可以有的一些内容，譬如运行时配置文件、开机自启动程序等。
2.18.7.VFS简介
	本节对linux内核的VFS机制做简单引入，让大家了解到内核中VFS层的目的和意义，这对后面学习应用和驱动的对应调用做了一定铺垫。
	
	

第三部分、随堂记录
2.18.1.根文件系统概述
2.18.1.1、为什么需要根文件系统
(1)init进程的应用程序在根文件系统上
(2)根文件系统提供了根目录/
(3)内核启动后的应用层配置(etc目录)在根文件系统上。几乎可以认为：发行版=内核+rootfs
(4)shell命令程序在根文件系统上。譬如ls、cd等命令
总结：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、/bin  /sbin等目录下的shell命令，还有/lib目录下的库文件等···）相配合才能工作。

2.18.1.2、根文件系统的实质是什么
(1)根文件系统是特殊用途的文件系统。
(2)根文件系统也必须属于某种文件系统格式。rootfstype=
(3)究竟文件系统是用来干嘛的。ZnFAT
首先，存储设备（块设备，像硬盘、flash等）是分块（扇区）的，物理上底层去访问存储设备时是按照块号（扇区号）来访问的。这就很麻烦。
其次，文件系统是一些代码，是一套软件，这套软件的功能就是对存储设备的扇区进行管理，将这些扇区的访问变成了对目录和文件名的访问。我们在上层按照特定的目录和文件名去访问一个文件时，文件系统会将这个目录+文件名转换成对扇区号的访问。
最后，不同的文件系统的差异就在于对这些扇区的管理策略和方法不同，譬如坏块管理、碎片管理。


2.18.2.根文件系统的形式
2.18.2.1、镜像文件形式
(1)使用专用工具软件制作的可供烧录的镜像文件
(2)镜像中包含了根文件系统中的所有文件
(3)烧录此镜像类似于对相应分区格式化。
(4)镜像文件系统具有一定的格式，格式是内化的，跟文件名后缀是无关的。
2.18.2.2、文件夹形式
(1)根文件系统其实就是一个包含特定内容的文件夹而已
(2)根文件系统可由任何一个空文件夹添加必要文件构成而成
(3)根文件系统的雏形就是在开发主机中构造的文件夹形式的
2.18.2.3、总结
(1)镜像文件形式的根文件系统主要目的是用来烧录到块设备上，设备上的内核启动后去挂载它。镜像文件形式的根文件系统是由文件夹形式的根文件系统使用专用的镜像制作工具制作而成的。
(2)最初在开发主机中随便mkdir创建了一个空文件夹，然后向其中添加一些必要的文件（包括etc目录下的运行时配置文件、/bin等目录下的可执行程序、/lib目录下的库文件等···）后就形成了一个文件夹形式的rootfs。然后这个文件夹形式的rootfs可以被kernel通过nfs方式来远程挂载使用，但是不能用来烧录块设备。我们为了将这个rootfs烧录到块设备中于是用一些专用的软件工具将其制作成可供烧录的一定格式的根文件系统镜像。
(3)文件夹形式的rootfs是没有格式的，制作成镜像后就有了一定的rootfs格式了，格式是由我们的镜像制作过程和制作工具来决定的。每一种格式的镜像制作工具的用法都不同。


2.18.3.自己制作ext2格式的根文件系统(空rootfs，只可挂载，不能执行)
2.18.3.1、mke2fs介绍
(1)mke2fs是一个应用程序，在ubuntu中默认是安装了的。这个应用程序就是用来制作ext2、ext3、ext4等格式的根文件系统的。
(2)一般用来制作各种不同格式的rootfs的应用程序的名字都很相似，类似于mkfs.xxx（譬如用来制作ext2格式的rootfs的工具叫mkfs.ext2、用来制作jffs2格式的rootfs的工具就叫mkfs.jffs2）
(3)ubuntu14.04中的mkfs.ext2等都是mke2fs的符号链接而已。

2.18.3.2、动手制作ext2格式的根文件系统(空的根文件系统，只能挂载，不能使用)
《参考资料：http://blog.csdn.net/zhengmeifu/article/details/24174513》
先mkdir my_rootfs(创建一个文件夹并cd进入这个文件夹，制作rootfs相关文件都在这个文件中执行)
(1)创建rootfs.ext2文件并且将之挂载到一个目录下方便访问它
	1.dd if=/dev/zero of=rootfs.ext2 bs=1024 count=2048
	2.losetup  /dev/loop1 rootfs.ext2
	3.mke2fs -m 0 /dev/loop1 2048
	4.mkdir rootfs
	5.mount -t ext2 /dev/loop1 ./rootfs/ 
	6.cd rootfs		touch linuxrc		cd ..
		我们向镜像中写入一个普通文件linuxrc。这个文件就会成为我们制作的镜像中的/linuxrc。内核挂载了这个镜像后就会尝试去执行/linuxrc。然后执行时必然会失败。我们将来实验看到的现象就应该是：挂载成功，执行/linuxrc失败。
		将来真正去做有用的rootfs时，就要在这一步添加真正可以执行的linuxrc程序，然后还要添加别的/lib目录下的库文件，/etc目录下的配置文件等。
(2)卸载掉，然后镜像就做好了。
	umount /dev/loop1
	losetup -d /dev/loop1

2.18.3.3、烧录制作的rootfs.ext2
(1)烧录过程参考裸机中第三部分的刷机过程。注意bootargs传参设置
	用fastboot flash system rootfs.ext2命令刷机重启查看挂载和执行情况
	
2.18.4、nfs方式启动自制简易文件夹形式的rootfs
2.18.4.1什么是nfs？
(1)nfs是一种网络通讯协议，由服务器和客户端构成。
(2)nfs的作用。利用nfs协议可以做出很多直接性应用，我们这里使用nfs主要是做rootfs挂载。开发板中运行kernel做nfs客户端，主机ubuntu中搭建nfs服务器。在主机ubuntu的nfs服务器中导出我们制作的文件夹形式的rootfs目录，则在客户端中就可以去挂载这个文件夹形式的rootfs进而去启动系统。

2.18.4.2搭建nfs服务器
1.安装nfs(虚拟机要能上网)
 sudo apt-get install nfs-kernel-server
 sudo apt-get install nfs-common
2.配置/etc/exports
 sudo vi /etc/exports
 添加：/my_rootfs/rootfs *(rw,sync,no_root_squash,no_subtree_check)
 保存并退出
 chmod 777 -R /my_rootfs/rootfs
 sudo showmount -e
 sudo exportfs -r
 sudo showmount localhost -e
 提示：
 		Export list for localhost:
		/my_rootfs/rootfs *
3.重启nfs服务
 sudo /etc/init.d/nfs-kernel-server restart 
 提示：
 	 * Stopping NFS kernel daemon                            [ OK ] 
	 * Unexporting directories for NFS kernel daemon...      [ OK ] 
	 * Exporting directories for NFS kernel daemon...        [ OK ] 
	 * Starting NFS kernel daemon                            [ OK ] 
4.将/my_rootfs/rootfs挂载到/opt
 mount -t nfs -o nolock localhost:/my_rootfs/rootfs /opt

5.完成后续卸载/opt
 umount /opt


2.18.4.3配置内核以支持nfs作为rootfs
(1)设置nfs启动方式的bootargs，在uboot中设置如下启动参数（IP根据实际使用更改）
setenv bootargs root=/dev/nfs nfsroot=192.168.1.141:/my_rootfs/rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off  init=/linuxrc console=ttySAC2,115200 

--------------------- 
作者：sean_dw 
来源：CSDN 
原文：https://blog.csdn.net/wang_shuai_ww/article/details/12012723 
版权声明：本文为博主原创文章，转载请附上博文链接！

setenv bootcmd tftp 30008000 zImage\; bootm 30008000

(2)在menuconfig中配置支持nfs启动方式
配置网络部分，主要是使能CONFIG_IP_PNP以在2中能够看到Root file system on NFS选项
Networking support 
	Networking options 
		TCP/IP networking
				IP: kernel level autoconfiguration
					[*] IP: DHCP support
					[*] IP: BOOTP support
					
配置开启nfs服务
File systems  --->	
	Network File Systems  --->
		<*> NFS client support 
		[*] NFS client support for NFS version 3                                  
		[*] NFS client support for the NFSv3 ACL protocol extension 
		[*] NFS client support for NFS version 4 (EXPERIMENTAL) 
		[*] NFS client support for NFSv4.1 (DEVELOPER ONLY) 
		[*] Root file system on NFS  

2.18.4.4总结
(1)nfs方式启动相当于开发板上的内核远程挂载到主机上的rootfs
(2)nfs方式启动不用制作rootfs镜像
(3)nfs方式不适合真正的产品，一般作为产品开发阶段调试使用	

2.18.5.到底什么是linuxrc
2.18.5.1、/linuxrc是一个可执行的应用程序
(1)/linuxrc是应用层的，和内核源码一点关系都没有
(2)/linuxrc在开发板当前内核系统下是可执行的。因此在ARM SoC的linux系统下，这个应用程序就是用arm-linux-gcc编译链接的；如果是在PC机linux系统下，那么这个程序就是用gcc编译连接的。
(3)/linuxrc如果是静态编译连接的那么直接可以运行；如果是动态编译连接的那么我们还必须给他提供必要的库文件才能运行。但是因为我们/linuxrc这个程序是由内核直接调用执行的，因此用户没有机会去导出库文件的路径，因此实际上这个/linuxrc没法动态连接，一般都是静态连接的。

2.18.5.2、/linuxrc执行时引出用户界面
(1)操作系统启动后在一系列的自己运行配置之后，最终会给用户一个操作界面（也许是cmdline，也许是GUI），这个用户操作界面就是由/linuxrc带出来的。
(2)用户界面等很多事并不是在/linuxrc程序中负责的，用户界面有自己专门的应用程序，但是用户界面的应用程序是直接或者间接的被/linuxrc调用执行的。用户界面程序和其他的应用程序就是进程2、3、4·····，这就是我们说的进程1（init进程，也就是/linuxrc）是其他所有应用程序进程的祖宗进程。

2.18.5.3、/linuxrc负责系统启动后的配置
(1)就好像一个房子建好之后不能直接住，还要装修一样；操作系统启动起来后也不能直接用，要配置下。
(2)操作系统启动后的应用层的配置（一般叫运行时配置，英文简写etc）是为了让我们的操作系统用起来更方便，更适合我个人的爱好或者实用性。

2.18.5.4、/linuxrc在嵌入式linux中一般就是busybox
(1)busybox是一个C语言写出来的项目，里面包含了很多.c文件和.h文件。这个项目可以被配置编译成各个平台下面可以运行的应用程序。我们如果用arm-linux-gcc来编译busybox就会得到一个可以在我们开发板linux内核上运行的应用程序。
(2)busybox这个程序开发出来就是为了在嵌入式环境下构建rootfs使用的，也就是说他就是专门开发的init进程应用程序。
(3)busybox为当前系统提供了一整套的shell命令程序集。譬如vi、cd、mkdir、ls等。在桌面版的linux发行版（譬如ubuntu、redhat、centOS等）中vi、cd、ls等都是一个一个的单独的应用程序。但是在嵌入式linux中，为了省事我们把vi、cd等所有常用的shell命令集合到一起构成了一个shell命令包，起名叫busybox。



2.18.6.rootfs中还应该有什么
2.18.6.1、最重要的就是上节课讲过的/linuxrc
2.18.6.2、dev目录下的设备文件。在linux中一切皆是文件，因此一个硬件设备也被虚拟化成一个设备文件来访问，在linux系统中/dev/xxx就表示一个硬件设备，我们要操作这个硬件时就是open打开这个设备文件，然后read/write/ioctl操作这个设备，最后close关闭这个设备。
在最小rootfs中/dev目录也是不可少的，这里面有一两个设备文件是rootfs必须的。
2.18.6.3、sys和proc目录。在最小rootfs中也是不可省略的，但是这两个只要创建了空文件夹即可，里面是没东西的，也不用有东西。这两个目录也是和驱动有关的。属于linux中的虚拟文件系统。
2.18.6.4、usr是系统的用户所有的一些文件的存放地，这个东西将来busybox安装时会自动生成。
2.18.6.5、etc目录是很关键很重要的一个，目录中的所有文件全部都是运行时配置文件。/etc目录下的所有配置文件会直接或者间接的被/linuxrc所调用执行，完成操作系统的运行时配置。etc目录是制作rootfs的关键，所以后面下一个课程专门讲这个etc目录。
2.18.6.6、lib目录也是rootfs中很关键的一个，不能省略的一个。lib目录下放的是当前操作系统中的动态和静态链接库文件。我们主要是为了其中的动态链接库。


2.18.7.VFS简介
2.18.7.1、什么是VFS
(1)VFS是linux内核的一种设计理念、设计机制。VFS就是vitrual file system，叫虚拟文件系统。
(2)具体的一些文件系统如FAT、NTFS、ext2、ext3、jffs2、yaffs2、ubi等主要设计目的是为了管理块设备（硬盘、Nand···）
(3)VFS是借鉴了文件系统的设计理念（通过文件系统将底层难以管理的物理磁盘扇区式访问，转换成目录+文件名的方式来访问），将硬件设备的访问也虚拟化成了对目录+文件的访问。所以有了VFS后我们可以通过设备文件（目录+文件名，譬如/dev/mmcblk0p2）的方式来访问系统中的硬件设备。
(4)以上可以初步看出VFS的一些厉害之处，但是VFS不止于此。

2.18.7.2、VFS的意义
(1)上面说过的对硬件设备的访问，将对硬件设备的访问和对普通文件的访问给接口统一化了（linux中一切届是文件）。
(2)将操作系统上层（应用层）对下层不同文件系统类型的访问细节给屏蔽掉了。因此如果没有VFS那我们写cp命令（其他命令也一样）的时候就不得不去考虑你cp的这个文件在什么文件系统类型下。所以cp命令非常复杂，因此要考虑具体的文件系统类型。有了VFS后情况就不同了。VFS成了一个隔离层，隔离了下层的不同文件系统的差异性，对上层应用提供一个统一的接口。
(3)VFS将不同文件系统和下层硬件设备（块设备）驱动之间的细节也给屏蔽了。不同类型的文件系统在本身设计时是不用考虑各种不同的硬件设备的具体操作差异的，这里有一个类似于VFS的设计理念。

2.18.7.3、VFS和我们学习的关系
(1)VFS机制和rootfs挂载，和其他文件系统的挂载都是有关联的。
(2)内核中有一些sys proc这种虚拟文件系统，这东西也是和VFS机制有关。
(3)/dev/目录下的设备文件都和VFS有关，所以学习驱动绕不开VFS。


