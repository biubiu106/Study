《1.12.ARM裸机第十二部分-I2C通信详解》

第一部分、章节目录
1.12.1.什么是I2C通信
1.12.2.由I2C学通信时序
1.12.3.S5PV210的I2C控制器
1.12.4.X210板载gsensor介绍
1.12.5.I2C总线的通信流程
1.12.6.I2C通信代码分析1
1.12.7.I2C通信代码分析2


第二部分、章节介绍
1.12.1.什么是I2C通信
	本节简单介绍I2C接口的物理特征、通信特征（串行、同步、非差分、低速率）、主从设备、总线式通信等概念，希望大家对I2C总线通信有个框架性的了解。
1.12.2.由I2C学通信时序
	本节主要讲解I2C总线的通信时序，希望借用I2C通信的时序分析让大家明白通信接口究竟是如何工作的。尽管现代SoC都是通过专用控制器来产生时序信号并不需自己编码，但是理解这些时序仍然对编程有很积极的作用。
1.12.3.S5PV210的I2C控制器
	本节介绍S5PV210的I2C控制器，主要讲了它的结构框图、时钟来源与分频、主要寄存器及其作用分析等。
1.12.4.X210板载gsensor介绍
	本节带领大家学习X210开发板上自带的gsensor芯片，主要是通过分析原理图、数据手册让大家对gsensor芯片的I2C接口、读写流程图等有个了解，以不影响I2C总线通信的学习。gsensor芯片本身的原理、寄存器列表、编程方法等并不是我们本课的重点。
1.12.5.I2C总线的通信流程
	本节结合S5PV210的数据手册，来讲解I2C总线的工作流程。主要讲解主发送、主接收这两种流程，同时结合gsensor数据手册中的操作流程来两方印证。实际的编程就是按照这些流程在写。
1.12.6.I2C通信代码分析1
	本节带大家分析I2C通信物理层的代码，源码来自于linux内核中。主要看了其中几个I2C发送接收的函数，通过函数的寄存器操作和上节讲的数据手册中的流程图相印证，让大家理解代码是怎么写出来的。
1.12.7.I2C通信代码分析2
	本节分析gsensor驱动，及其与I2C物理层驱动的关联。通过这种层次结合和调用，让大家对驱动的分层有所理解。
第三部分、随堂记录
1.12.1.什么是I2C通信
1.12.1.1、物理接口：SCL + SDA
(1)SCL(serial clock)：时钟线，传输CLK信号，一般是I2C主设备向从设备提供时钟的通道。
(2)SDA(serial data): 数据线，通信数据都通过SDA线传输

1.12.1.2、通信特征：串行、同步、非差分、低速率
(1)I2C属于串行通信，所有的数据以位为单位在SDA线上串行传输。
(2)同步通信就是通信双方工作在同一个时钟下，一般是通信的A方通过一根CLK信号线传输A自己的时钟给B，B工作在A传输的时钟下。所以同步通信的显著特征就是：通信线中有CLK
(3)非差分。因为I2C通信速率不高，而且通信双方距离很近，所以使用电平信号通信。
(4)低速率。I2C一般是用在同一个板子上的2个IC之间的通信，而且用来传输的数据量不大，所以本身通信速率很低（一般几百KHz，不同的I2C芯片的通信速率可能不同，具体在编程的时候要看自己所使用的设备允许的I2C通信最高速率，不能超过这个速率）

1.12.1.3、突出特征1：主设备+从设备
(1)I2C通信的时候，通信双方地位是不对等的，而是分主设备和从设备。通信由主设备发起，由主设备主导，从设备只是按照I2C协议被动的接受主设备的通信，并及时响应。
(2)谁是主设备、谁是从设备是由通信双方来定的（I2C协议并无规定），一般来说一个芯片可以只能做主设备、也可以只能做从设备、也可以既能当主设备又能当从设备（软件配置）。

1.12.1.3、突出特征2：可以多个设备挂在一条总线上（从设备地址）
(1)I2C通信可以一对一（1个主设备对1个从设备），也可以一对多（1个主设备对多个从设备）。
(2)主设备来负责调度总线，决定某一时间和哪个从设备通信。注意：同一时间内，I2C的总线上只能传输一对设备的通信信息，所以同一时间只能有一个从设备和主设备通信，其他从设备处于“冬眠”状态，不能出来捣乱，否则通信就乱套了。
(3)每一个I2C从设备在通信中都有一个I2C从设备地址，这个设备地址是从设备本身固有的属性，然后通信时主设备需要知道自己将要通信的那个从设备的地址，然后在通信中通过地址来甄别是不是自己要找的那个从设备。（这个地址是一个电路板上唯一的，不是全球唯一的）

1.12.1.3、主要用途：SoC和周边外设之间的通信（典型的如EEPROM、电容触摸IC、各种sensor等）


1.12.2.由I2C学通信时序
1.12.2.1、什么是时序？
(1)时序：字面意思，时序就是时间顺序，实际上在通信中时序就是通信线上按照时间顺序发生的电平变化，以及这些变化对通信的意义就叫时序。

1.12.2.2、I2C的总线空闲状态、起始位、结束位
(1)I2C总线上有1个主设备，n（n>=1）个从设备。I2C总线上有2种状态；空闲态（所有从设备都未和主设备通信，此时总线空闲）和忙态（其中一个从设备在和主设备通信，此时总线被这一对占用，其他从设备必须歇着）。
(2)整个通信分为一个周期一个周期的，两个相邻的通信周期是空闲态。每一个通信周期由一个起始位开始，一个结束位结束，中间是本周期的通信数据。
(3)起始位并不是一个时间点，起始位是一个时间段，在这段时间内总线状态变化情况是：SCL线维持高电平，同时SDA线发生一个从高到低的下降沿。
(4)与起始位相似，结束位也是一个时间段。在这段时间内总线状态变化情况是：SCL线维持高电平，同时SDA线发生一个从低到高的上升沿。

1.12.2.3、I2C数据传输格式（数据位&ACK）
(1)每一个通信周期的发起和结束都是由主设备来做的，从设备只有被动的响应主设备，没法自己自发的去做任何事情。
(2)主设备在每个通信周期会先发8位的从设备地址（其实8位中只有7位是从设备地址，还有1位表示主设备下面要写入还是读出）到总线（主设备是以广播的形式发送的，只要是总线上的所有从设备其实都能收到这个信息）。然后总线上的每个从设备都能收到这个地址，并且收到地址后和自己的设备地址比较看是否相等。如果相等说明主设备本次通信就是给我说话，如果不想等说明这次通信与我无关，不用听了不管了。
(3)发送方发送一段数据后，接收方需要回应一个ACK。这个响应本身只有1个bit位，不能携带有效信息，只能表示2个意思（要么表示收到数据，即有效响应；要么表示未收到数据，无效响应）
(4)在某一个通信时刻，主设备和从设备只能有一个在发（占用总线，也就是向总线写），另一个在收（从总线读）。如果在某个时间主设备和从设备都试图向总线写那就完蛋了，通信就乱套了。

1.12.3.4、数据在总线上的传输协议
(1)I2C通信时的基本数据单位也是以字节为单位的，每次传输的有效数据都是1个字节（8位）。
(2)起始位及其后的8个clk中都是主设备在发送（这设备掌控总线），此时从设备只能读取总线，通过读总线来得知主设备发给从设备的信息；然后到了第9周期，按照协议规定从设备需要发送ACK给主设备，所以此时主设备必须释放总线（主设备把总线置为高电平然后不要动，其实就类似于总线空闲状态），同时从设备试图拉低总线发出ACK。如果从设备拉低总线失败，或者从设备根本就没有拉低总线，则主设备看到的现象就是总线在第9周期仍然一直保持高，这对主设备来说，意味着我没收到ACK，主设备就认为刚才给从设备发送的8字节不对（接收失败）

1.12.3.S5PV210的I2C控制器
通信双方本质上是通过时序在工作，但是时序会比较复杂不利于SoC软件完成，于是乎解决方案是SoC内部内置了硬件的控制器来产生通信时序。这样我们写软件时只需要向控制器的寄存器中写入配置值即可，控制器会产生适当的时序在通信线上和对方通信。
1.12.3.1、结构框图
(1)时钟部分，时钟来源是PCLK_PSYS，经过内部分频最终得到I2C控制器的CLK，通信中这个CLK会通过SCL线传给从设备。
(2)I2C总线控制逻辑（前台代表是I2CCON、I2CSTAT这两个寄存器），主要负责产生I2C通信时序。实际编程中要发送起始位、停止位、接收ACK等都是通过这两个寄存器（背后所代表的电路模块）实现的。
(3)移位寄存器（shift register），将代码中要发送的字节数据，通过移位寄存器变成1个位一个位的丢给SDA线上去发送/接收。学过数字电路的同学应该对移位寄存器不陌生。
(4)地址寄存器+比较器。本I2C控制器做从设备的时候用。(我没用过，理论分析)

1.12.3.2、系统分析I2C的时钟
(1)I2C时钟源头来源于PCLK（PCLK_PSYS，等于65MHz），经过了2级分频后得到的。
(2)第一级分频是I2CCON的bit6，可以得到一个中间时钟I2CCLK（等于PCLK/16或者PCLK/512）
(3)第二级分频是得到最终I2C控制器工作的时钟，以I2CCLK这个中间时钟为来源，分频系数为[1,16]
(4)最终要得到时钟是2级分频后的时钟，譬如一个可用的设置是：65000KHz/512/4=31KHz

1.12.3.3、主要寄存器I2CCON、I2CSTAT、I2CADD、I2CDS
I2CCON + I2CSTAT：主要用来产生通信时序和I2C接口配置。
I2CADD：用来写自己的slave address
I2CDS：发送/接收的数据都放在这里

1.12.4.X210板载gsensor介绍
1.12.4.1、原理图查阅
(1)gsensor的供电由PWMTOUT3引脚控制。当PWMTOUT3输出低电平时gsensor无电不工作；当输出高电平时gsensor才会工作。
(2)gsensor的SDA和SCL接的是S5PV210的I2C端口0
(3)将来编程时在gsensor_init函数中要去初始化相关的GPIO。要把相应的GPIO设置为正确的模式和输入输出值。

1.12.4.2、重力加速度传感器简介
(1)用在手机、平板、智能手表等设备上，用来感受人的手的移动，获取一些运动的方向性信息用来给系统作为输入参量。
(2)可以用来设计智能手表的计步器功能。
(3)重力加速度传感器、地磁传感器、陀螺仪等三个传感器结合起来，都是用来感谢运动的速度、方位等信息的，所以现在最新的有9轴传感器，就是把三者结合起来，并且用一定的算法进行综合得出结论，目的是更加准确。
(4)一般传感器的接口有2种：模拟接口和数字接口。模拟接口是用接口电平变化来作为输出的（譬如模拟接口的压力传感器，在压力不同时输出电平在0～3.3V范围内变化，每一个电压对应一个压力。），SOC需要用AD接口来对接这种传感器对它输出的数据进行AD转换，转换得到数字电压值，再用数字电压值去校准得到压力值；数字接口是后来发展出来的，数字接口的sensor是在模拟接口的sensor基础上，内部集成了AD，直接（通过一定的总线接口协议，一般是i2C）输出一个数字值的参数，这样SoC直接通过总线接口初始化、读取传感器输出的参数即可（譬如gsensor、电容触摸屏IC）。

1.12.4.3、I2C从设备的设备地址
(1)KXTE9的I2C地址固定为0b0001111（0x0f）
(2)I2C从设备地址本身是7位的，但是在I2C通信中发送I2C从设备地址时实际发送的是8位，这8位中高7位（bit7-bit1）对应I2C从设备的7位地址，最低一位（LSB）存放的是R/W信息（就是说下一个数据是主设备写从设备读（对应0），还是主设备读从设备写（对应1））
(3)基于上面讲的，对于KXTE9来说，主设备（SoC）发给gsensor信息时，SAD应该是：0b00011110(0x1E)
如果是主设备读取gsensor信息时，SAD应该是：0b00011111（0x1F）

1.12.4.4、I2C从设备的通信速率
(1)I2C协议本身属于低速协议，通信速率不能太高。
(2)实际上通信的主设备和从设备本身都有最高的通信速率限制（属于各个芯片本身的参数），实际编程时怎么确定最终的通信速率？只要小于两个即可。
(3)一般来说只能做从设备的sensor芯片本身i2c通信速率偏低，像KXTE9最高支持400KHz的频率。


1.12.5.I2C总线的通信流程
1.12.5.1、S5PV210的主发送流程图
1.12.5.2、S5PV210的主接收流程图
1.12.5.3、gsensor的写寄存器流程图
1.12.5.4、gsensor的读寄存器流程图


1.12.6.I2C通信代码分析1
1.12.6.1、I2C控制器初始化：s3c24xx_i2c_init
(1)初始化做的事情：初始化GPIO，设置IRQEN和ACKEN，初始化I2C时钟
1.12.6.2、I2C控制器主模式开始一次读写：s3c24xx_i2c_message_start

1.12.6.3、I2C控制器主模式结束一次读写：s3c24xx_i2c_stop


1.12.7.I2C通信代码分析2
框架分析：我们最终目的是通过读写gsensor芯片的内部寄存器来得到一些信息。为了完成这个目的，我们需要能够读写gsensor的寄存器，根据gsensor的规定我们需要按照一定的操作流程来读写gsensor的内部寄存器，这是一个层次（姑且叫做传输层、协议层、应用层）；我们要按照操作流程去读写寄存器，就需要考虑I2C接口协议（这就是所谓的物理层，本质就是那些时序）。此时主机SoC有或者没有控制器，有控制器时考虑控制器的寄存器，没控制器时要自己软件模拟时序。
协议层的代码主要取决于gsensor芯片；物理层代码主要取决于主机SoC。


1.12.7.1、gsensor写寄存器：gsensor_i2c_write_reg
1.12.7.2、gsensor读寄存器：gsensor_i2c_read_reg
1.12.7.3、gsensor编程：gsensor_initial等


