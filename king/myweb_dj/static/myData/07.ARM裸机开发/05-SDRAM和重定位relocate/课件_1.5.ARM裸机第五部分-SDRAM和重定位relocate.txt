《1.5.ARM裸机第五部分-SDRAM和重定位relocate》

第一部分、章节目录
1.5.1.汇编写启动代码之关看门狗
1.5.2.汇编写启动代码之设置栈和调用C语言1
1.5.3.汇编写启动代码之设置栈和调用C语言2
1.5.4.汇编写启动代码之开iCache
1.5.5.重定位引入和链接脚本1
1.5.6.重定位引入和链接脚本2
1.5.7.重定位引入和链接脚本3
1.5.8.代码重定位实战1
1.5.9.代码重定位实战2
1.5.10.SDRAM引入
1.5.11.SDRAM初始化
1.5.12.汇编初始化SDRAM详解1
1.5.13.汇编初始化SDRAM详解2

第二部分、章节介绍
1.5.1.汇编写启动代码之关看门狗
	使用汇编在启动代码中关闭看门狗，以防止启动过程中不喂狗导致复位。目的是让大家认识看门狗这个外设，同时进一步熟悉ARM汇编程序编写
1.5.2.汇编写启动代码之设置栈和调用C语言1
	本节主要讲解C语言运行时环境和栈的重要性，然后分析了S5PV210的栈寄存器SP，进一步查阅文档确定启动代码中规划的栈内存区间，最终使用汇编编程设置栈以便调用C语言程序
1.5.3.汇编写启动代码之设置栈和调用C语言2
	本节接上节将之前第三部分中的led程序由汇编更改为C程序，然后被汇编调用。通过实验告诉大家汇编程序是如何调用C程序进行交互的。
1.5.4.汇编写启动代码之开iCache
	本节主要讲解cache的概念和作用，为什么需要cache，以及在210中如何通过汇编操作cp15开打开/关闭cache。
1.5.5.重定位引入和链接脚本1
	本节讲解了几个重要概念，包括：位置无关码PIC、链接地址和运行地址，然后再次结合S5PV210的启动过程分析，最终目的是让大家明白为什么需要重定位
1.5.6.重定位引入和链接脚本2
	本节首先讲了链接地址和运行地址各自由什么决定，然后简单讲述代码编译链接的步骤，最后重点讲了各种段，如代码段、数据段、bss段等的含义。
1.5.7.重定位引入和链接脚本3
	本节接上节讲述各种段的含义，最后以一个简单的链接脚本为例讲述了链接脚本的构成和解读方法。
1.5.8.代码重定位实战1
	本节开始重定位实战，首先明确任务（在sram内进行重定位），然后重点讲解了实现思路及步骤，为下节课写代码打好基础。
1.5.9.代码重定位实战2
	本节讲解SRAM内部重定位的代码，着重讲了adr与ldr伪指令的区别、重定位的copy汇编代码、清除bss段的代码等模块，目的是让大家彻底掌握重定位。
1.5.10.SDRAM引入
	本节首先讲解SDRAM和DDR的联系和区别，然后粗略讲了SDRAM的特性，最后带大家简单读了SDRAM芯片的手册，为后面写代码时查阅手册打好了基础。
1.5.11.SDRAM初始化
	本节首先从原理图出发，带领大家详细分析X210核心板原理图中DDR SDRAM芯片的相关部分，得出一些参数；然后再结合数据手册内容得到另一些参数，这些参数在之后的代码中都会用得到。
	
1.5.12.汇编初始化SDRAM详解1
	本节开始讲解SDRAM初始化代码，首先引导大家找到数据手册上27步初始化DRAM的部分，然后逐项分析代码。本节主要分析了设置引脚驱动能力，和DLL锁存部分。
1.5.13.汇编初始化SDRAM详解2
	本节接上节继续讲解SDRAM初始化代码，主要讲了几个关键性寄存器的参数值设置。最后在DRAM初始化后将代码重定位到DRAM上运行，完成本章内容。

第三部分、随堂记录
1.5.1.汇编写启动代码之关看门狗
1.5.1.1、什么是看门狗？
	看门狗（watch dog timer 看门狗定时器）。大家想象这样一个场景：家门口有一只狗，这个狗定时会饿（譬如说2小时一饿），够饿了会胡乱咬死人。人进进出出要想保证安全必须提前喂狗（必须在上次喂过后的2小时内喂狗才行）。如果超时没喂狗就会被咬死，如果提前喂狗没关系，但是本次喂狗时间就会从这里开始计算。
	现实中因为一些外部因素，电子设备经常会跑飞或者死机（譬如极端炎热、极端寒冷、工业复杂场合）。在这种情况下我们希望设备自动复位而不需要人工干预（无人值守）。看门狗用来完成这个工作。看门狗其实是我们SoC内部的一个定时器（类似于闹钟，类似于门口的狗），定好时间之后看门狗定时器会去计时，时间到之前（狗饿了之前）必须去重新置位看门狗定时器（喂狗），如果没有喂狗则系统会被强制复位。
	系统在正常工作时，系统软件会自己去喂狗，所以看门狗定时器不会复位。但是系统一旦故障跑飞啥的，看门狗就没人喂了，然后下一个周期就会自动复位，达到我们期望的效果。
	
1.5.1.2、分析硬件物理特性、原理图、数据手册
	物理特性上看门狗其实是个定时器（跟现实中的闹钟类似），硬件上就是SoC内部的一个内部外设。
	原理图：看门狗不用分析原理图，因为看门狗属于内部外设，且没有外部相关的原件与他有关，所以不需要原理图分析，原理图上根本找不到和看门狗有关的地方。
	数据手册：在数据手册的Section7.3，大家可以详细来看。如果直接看不懂数据手册，可以百度看门狗，然后看别人的博客来学习。
	
1.5.1.3、找到关键性操作SFR（特殊功能寄存器）
	WTCON（0xE2700000），其中bit5是看门狗的开关：0代表关，1代表开
1.5.1.4、编写汇编代码

1.5.1.5、总结210中看门狗特性（iROM中已经关看门狗）
	为什么要关看门狗？
	一般CPU设计，在CPU启动后看门狗默认是工作的（为什么默认不关闭而要工作？我猜测是因为怕你的程序在启动代码前端就死机了或者跑飞了没人管），好处就是没有空当和漏洞，坏处就是在启动代码段我们不方便去喂狗（或者说懒得去喂狗）时看门狗会复位，所以为了偷懒我们就在启动代码前端先去关闭看门狗，然后在后面系统启动起来之后再根据需要决定是否要打开看门狗（一旦打开就必须同时提供喂狗）。
	在S5PV210内部的iROM代码（BL0）中，其实已经关过看门狗了。所以我们的启动代码实际上是不用去关也没事的，也就是说今天写的关闭看门狗的代码运行后没有任何现象（没有现象就是正常现象）.
	很多CPU内部是没有BL0的，因此也没人给你关看门狗，都要在启动代码前段自己写代码关看门狗，所以今天学习的内容也是有价值的。

1.5.2.汇编写启动代码之设置栈和调用C语言1
1.5.2.1、C语言运行时需要和栈的意义
	“C语言运行时（runtime）”需要一定的条件，这些条件由汇编来提供。C语言运行时主要是需要栈
	C语言与栈的关系：C语言中的局部变量都是用栈来实现的。如果我们汇编部分没有给C部分预先设置合理合法的栈地址，那么C代码中定义的局部变量就会落空，整个程序就死掉了。
	我们平时在编写单片机程序（譬如51单片机）或者编写应用程序时并没有去设置栈，但是C程序还是可以运行的。原因是：在单片机中由硬件初始化时提供了一个默认可用的栈，在应用程序中我们编写的C程序其实并不是全部，编译器（gcc）在链接的时候会帮我们自动添加一个头，这个头就是一段引导我们的C程序能够执行的一段汇编实现的代码，这个代码中就帮我们的C程序设置了栈及其他的运行时需要。
1.5.2.2、CPU模式和各种模式下的栈
	在ARM中37个寄存器中，每种模式下都有自己的独立的SP寄存器（r13），为什么这么设计？
	如果各种模式都使用同一个SP，那么就意味着整个程序（操作系统内核程序、用户自己编写的应用程序）都是用一个栈的。你的应用程序如果一旦出错（譬如栈溢出），就会连累操作系统的栈也损坏，整个操作系统的程序就会崩溃。这样的操作系统设计是非常脆弱的，不合理的。
	解决方案就是各种模式下用不同的栈。我的操作系统内核使用自己的栈，每个应用程序也使用自己独立的栈，这样各是各的，一个损坏不会连累其他人。
	我们现在要设置栈，不可能也懒的而且也没有必要去设置所有的栈，我们先要找到自己的模式，然后设置自己的模式下的栈到合理合法的位置，即可。
	注意：系统在复位后默认是进入SVC模式的
	我们如何访问SVC模式下的SP呢？很简单，先把模式设置为SVC，再直接操作SP。但是因为我们复位后就已经是SVC模式了，所以直接设置SP即可。

1.5.2.3、查阅文档并设置栈指针至合法位置
	栈必须是当前一段可用的内存（可用的意思是这个地方必须有被初始化过可以访问的内存，而且这个内存只会被我们用作栈，不会被其他程序征用）
	当前CPU刚复位（刚启动），外部的DRRAM尚未初始化，目前可用的内存只有内部的SRAM（因为它不需初始化即可使用）。因此我们只能在SRAM中找一段内存来作为SVC的栈。
	栈有四种：满减栈 满增栈 空减栈 空增栈
	满栈：进栈：先移动指针再存； 出栈：先出数据再移动指针
	空栈：xxx
	减栈：进栈：指针向下移动；	 出栈：指针向上移动
	增栈：xxx
	在ARM中，ATPCS（ARM关于程序应该怎么实现的一个规范）要求使用满减栈，所以不出意外都是用满减栈
	结合iROM_application_note中的memory map，可知SVC栈应该设置为0xd0037D80
1.5.2.4、汇编程序和C程序互相调用
	bl cfuncion

1.5.3.汇编写启动代码之设置栈和调用C语言2
1.5.3.1、C函数的编写和被汇编调用
	在工程中新建并且添加一个C语言源文件（led.c），注意添加时要修改Makefile
	在汇编启动代码中设置好栈后，使用bl xxx的方式来调用C中的函数xxx

1.5.3.2、使用C语言来访问寄存器的语法
	寄存器的地址类似于内存地址（IO与内存统一编址的），所以这里的问题是用C语言读写寄存器，就是用C语言来读写内存地址。用C语言来访问内存，就要用到指针
	unsigned int *p = (unsigned int *)0x0xE0200240;
	*p = 0x11111111;
	上面这两句其实可以简化为1句：*((unsigned int *)0x0xE0200240) = 0x11111111;
	这样就可以用宏定义#define rGPJOCON *((unsigned int *)0x0xE0200240)    rGPJ0CON = 0x11111111;
	
1.5.3.3、神奇的volatile
	volatile的作用是让程序在编译时，编译器不对程序做优化。优化有时候是ok的，但是有时候是自作聪明会造成程序不对。如果你的一个变量是易变的，不希望编译器帮我们做优化，就在这个变量定义时加volatile。
	加不加有没有差别，取决于编译器。如果编译器做了优化则有差异；如果编译器本身没做优化，那就没有差别。
	在我们这里（编译器是arm-2009q3），实际测试加不加效果是一样的。
1.5.3.4、总结：
	C和汇编函数的互相调用（函数名和汇编标号的真实意义）
	C语法对内存访问的封装方式（使用指针来访问内存的技巧）
	汇编的意义（起始代码&效率关键部位）
	
1.5.3.5、编译报错（实际上是连接阶段报错）：undefined reference to `__aeabi_unwind_cpp_pr1'	
	解决方法：把错误信息直接贴到baidu搜索（baidu搜索不到找google），根据搜索到的内容一个一个看，一个一个尝试，直到解决。
	解决：在编译时添加-nostdlib这个编译选项即可解决。nostdlib就是不使用标准函数库。标准函数库就是编译器中自带的函数库，用-nostdlib可以让编译器链接器优先选择我程序内自己写的函数库。


1.5.4.汇编写启动代码之开iCache
1.5.4.1、什么是cache，有什么用
	cache是一种内存，叫高速缓存。
从容量来说：CPU <　寄存器 < cache < DDR
从速度来说：CPU >  寄存器 > cache > DDR
	cache的存在，是因为寄存器和ddr之间速度差异太大，ddr的速度远不能满足寄存器的需要（不能满足cpu的需要，所以没有cache会拉低整个系统的整体速度）
整个系统中CPU的供应链由：寄存器+cache+DDR+硬盘/flash四阶组成，这是综合考虑了性能、成本后得到的妥协的结果。
210内部有32KB icache和32kb dcache。icache是用来缓存指令的；dcache是用来缓存数据的。

cache的意义：指令平时是放在硬盘/flash中的，运行时读取到DDR中，再从DDR中读给寄存器，再由寄存器送给cpu。但是DDR的速度和寄存器（代表的就是CPU）相差太大，如果CPU运行完一句再去DDR读取下一句，那么CPU的速度完全就被DDR给拖慢了。解决方案就是icache。
icache工作时，会把我们CPU正在运行的指令的旁边几句指令事先给读取到icache中（CPU设计有一个基本原理：代码执行时，下一句执行当前一句代码旁边代码的可能性要大很多）。当下一句CPU要指令时，cache首先检查自己事先准备的缓存指令中有没这句，如果有就直接拿给CPU，如果没有则需要从DDR中重新去读取拿给CPU，并同时做一系列的动作：清缓存、重新缓存。

1.5.4.2、iROM中BL0对cache的操作
首先，icache的一切动作都是自动的，不需人为干预。我们所需要做的就是打开/关闭icache。
其次，在210的iROM中BL0已经打开了icache。所以之前看到的现象都是icache打开时的现象。
1.5.4.3、汇编代码读写cp15以开关icache
	mrc p15,0,r0,c1,c0,0;			// 读出cp15的c1到r0中
	bic r0, r0, #(1<<12)			// bit12 置0  关icache
	orr r0, r0, #(1<<12)			// bit12 置1  开icache
	mcr p15,0,r0,c1,c0,0;
1.5.4.4、实验验证
我们来看三种情况下的实验现象：
	1 直接使用BL0中对icache的操作
	2 关icache
	3 开icache
实验结果分析：
	结论1：irom中确实是打开了icache的。
	结论2：icache关闭确实比icache打开时led闪烁变慢，说明指令执行速度变慢。


1.5.5.重定位引入和链接脚本1
1.5.5.1、一个事实：大部分指令是位置有关编码
位置无关编码(PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。
位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。

我们在设计一个程序时，会给这个程序指定一个运行地址（链接地址）。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。

对比：位置无关代码要好一些，适应性强，放在哪里都能正常运行；位置有关代码就必须运行在链接时指定的地址上，适应性差。位置无关码有一些限制，不能完成所有功能，有时候不得不使用位置有关代码。

1.5.5.2、链接地址和运行地址：可能相同也可能不同
对于位置有关代码来说：最终执行时的运行地址和编译链接时给定的链接地址必须相同，否则一定出错。
我们之前的裸机程序中，Makefile中用 -Ttext 0x0 来指定链接地址是0x0。这意味着我们认为这个程序将来会放在0x0这个内存地址去运行。
但是实际上我们运行时的地址是0xd0020010(我们用dnw下载时指定的下载地址)。这两个地址看似不同，但是实际相同。这是因为S5PV210内部做了映射，把SRAM映射到了0x0地址去。

分清楚这两个概念：
链接地址：链接时指定的地址（指定方式为：Makefile中用-Ttext，或者链接脚本）
运行地址：程序实际运行时地址（指定方式：由实际运行时被加载到内存的哪个位置说了算）

1.5.5.3、再解S5PV210的启动过程：三星推荐和uboot的实现是不同的
三星推荐的启动方式中：bootloader必须小于96KB并大于16KB，假定bootloader为80KB，启动过程是这样子：先开机上电后BL0运行，BL0会加载外部启动设备中的bootloader的前16KB（BL1）到SRAM中去运行，BL1运行时会加载BL2（bootloader中80-16=64KB）到SRAM中（从SRAM的16KB处开始用）去运行；BL2运行时会初始化DDR并且将OS搬运到DDR去执行OS，启动完成。
uboot实际使用的方式：uboot大小随意，假定为200KB。启动过程是这样子：先开机上电后BL0运行，BL0会加载外部启动设备中的uboot的前16KB（BL1）到SRAM中去运行，BL1运行时会初始化DDR，然后将整个uboot搬运到DDR中，然后用一句长跳转（从SRAM跳转到DDR）指令从SRAM中直接跳转到DDR中继续执行uboot直到uboot完全启动。uboot启动后在uboot命令行中去启动OS。

1.5.5.4、现在明白为什么要重定位了吧？
原因：
	链接地址和运行地址有时候必须不相同，而且还不能全部用位置无关码，这时候只能重定位。
扩展：
	分散加载：把uboot分成2部分（BL1和整个uboot），两部分分别指定不同的链接地址。启动时将两部分加载到不同的地址（BL1加载到SRAM，整个uboot加载到DDR），这时候不用重定位也能启动。
评价：分散加载其实相当于手工重定位。重定位是用代码来进行重定位，分散加载是手工操作重定位的。

1.5.6.重定位引入和链接脚本2
1.5.6.1、运行时地址由什么决定？
	运行时的地址是由运行时决定的（编译链接时是无法绝对确定运行时地址的）
1.5.6.2、链接地址由什么决定？
	链接地址是由程序员在编译链接的过程中，通过Makefile中-Ttext xxx或者在链接脚本中指定的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。
举例：1、linux中的应用程序。gcc hello.c -o hello，这时使用默认的链接地址就是0x0，所以应用程序都是链接在0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享4G的虚拟地址空间。所以应用程序都可以链接到0地址，因为每个进程都是从0地址开始的。（编译时可以不给定链接地址而都使用0）
	  2、210中的裸机程序。运行地址由我们下载时确定，下载时下载到0xd0020010，所以就从这里开始运行。（这个下载地址也不是我们随意定的，是iROM中的BL0加载BL1时事先指定好的地址，这是由CPU的设计决定的）。所以理论上我们编译链接时应该将地址指定到0xd0020010，但是实际上我们在之前裸机程序中都是使用位置无关码PIC，所以链接地址可以是0。
	
1.5.6.3、从源码到可执行程序的步骤：预编译、编译、链接、strip
	预编译：预编译器执行。譬如C中的宏定义就是由预编译器处理，注释等也是由预编译器处理的。
	编译：  编译器来执行。把源码.c .S编程机器码.o文件。
	链接：	链接器来执行。把.o文件中的各函数（段）按照一定规则（链接脚本来指定）累积在一起，
			形成可执行文件。
	strip： strip是把可执行程序中的符号信息给拿掉，以节省空间。（Debug版本和Release版本）
	objcopy：由可执行程序生成可烧录的镜像bin文件。
	
1.5.6.4、程序段的概念：代码段、数据段、bss段（ZI段）、自定义段
段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段站在核实的位置。

段名分为2种：一种是编译器链接器内部定好的，先天性的名字；一种是程序员自己指定的、自定义的段名。
先天性段名：
	代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西
	数据段：（.data），数据段就是C语言中有显式初始化为非0的全局变量
	bss段：（.bss），又叫ZI（zero initial）段，就是零初始化段，对应C语言中初始化为0的全局变量。
后天性段名：
	段名由程序员自己定义，段的属性和特征也由程序员自己定义。
	
分析一些问题，跟这里结合，然后试图明白一些本质：
1、C语言中全局变量如果未显式初始化，值是0。本质就是C语言把这类全局变量放在了bss段，从而保证了为0
2、C运行时环境如何保证显式初始化为非0的全局变量的值在main之前就被赋值了？就是因为它把这类变量放在了.data段中，而.data段会在main执行之前被处理（初始化）。
	
1.5.6.5、链接脚本究竟要做什么？
链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理.o文件中那些段，将其链接成一个可执行程序。
	链接脚本的关键内容有2部分：段名 + 地址（作为链接地址的内存地址）
	链接脚本的理解：
	SECTIONS {}	这个是整个链接脚本
	. 点号在链接脚本中代表当前位置。
	= 等号代表赋值

1.5.8.代码重定位实战1
1.5.8.1、任务：在SRAM中将代码从0xd0020010重定位到0xd0024000
	任务解释：本来代码是运行在0xd0020010的，但是因为一些原因我们又希望代码实际是在0xd0024000位置运行的。这时候就需要重定位了。
注解：本练习对代码本身运行无实际意义，我们做这个重定位纯粹是为了练习重定位技能。但是某些情况重定位就是必须的，譬如在uboot中。
	
1.5.8.2、思路：
			第一点：通过链接脚本将代码链接到0xd0024000
			第二点：dnw下载时将bin文件下载到0xd0020010
第一点加上第二点，就保证了：代码实际下载运行在0xd0020010，但是却被链接在0xd0024000。从而为重定位奠定了基础。
当我们把代码链接地址设置为0xd0024000时，实际隐含意思就是我这个代码将来必须放在0xd0024000位置才能正确执行。如果实际运行地址不是这个地址就要出事（除非代码是PIC位置无关码），当以上都明白了后，就知道重定位代码的作用就是：在PIC执行完之前（在代码中第一句位置有关码执行之前）必须将整个代码搬移到0xd0024000位置去执行，这就是重定位。
			第三点：代码执行时通过代码前段的少量位置无关码将整个代码搬移到0xd0024000
			第四点：使用一个长跳转跳转到0xd0024000处的代码继续执行，重定位完成
长跳转：首先这句代码是一句跳转指令（ARM中的跳转指令就是类似于分支指令B、BL等作用的指令），跳转指令通过给PC（r15）赋一个新值来完成代码段的跳转执行。长跳转指的是跳转到的地址和当前地址差异比较大，跳转的范围比较宽广。
当我们执行完代码重定位后，实际上在SRAM中有2份代码的镜像（一份是我们下载到0xd0020010处开头的，另一份是重定位代码复制到0xd0024000处开头的），这两份内容完全相同，仅仅地址不同。重定位之后使用ldr pc, =led_blink这句长跳转直接从0xd0020010处代码跳转到0xd0024000开头的那一份代码的led_blink函数处去执行。（实际上此时在SRAM中有2个led_blink函数镜像，两个都能执行，如果短跳转bl led_blink则执行的就是0xd0020010开头的这一份，如果长跳转ldr pc, =led_blink则执行的是0xd0024000开头处的这一份）。这就是短跳转和长跳转的区别。

当链接地址和运行地址相同时，短跳转和长跳转实际效果是一样的；但是当链接地址不等于运行地址时，短跳转和长跳转就有差异了。这时候短跳转实际执行的是运行地址处的那一份，而长跳转执行的是链接地址处那一份。

总结：重定位实际就是在运行地址处执行一段位置无关码PIC，让这段PIC（也就是重定位代码）从运行地址处把整个程序镜像拷贝一份到链接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到链接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。
1.5.8.3、链接脚本分析讲解

1.5.9.代码重定位实战2
1.5.9.1、adr与ldr伪指令的区别
	ldr和adr都是伪指令，区别是ldr是长加载、adr是短加载。
重点：adr指令加载符号地址，加载的是运行时地址；ldr指令在加载符号地址时，加载的是链接地址。

深入分析：只要知道adr和ldr分别用于加载运行地址和链接地址，从而可以判断是否需要重定位即可；根本不需知道为什么adr和ldr是这样子，但是我们还是给大家扩展讲下为什么adr和ldr可以加载不同的地址。

1.5.9.2、重定位（代码拷贝）
	重定位就是汇编代码中的copy_loop函数，代码的作用是使用循环结构来逐句复制代码到链接地址。
	复制的源地址是SRAM的0xd0020010，复制目标地址是SRAM的0xd0024000，复制长度是bss_start减去_start
	所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段+数据段的长度。
	bss段（bss段中就是0初始化的全局变量）不需要重定位。
1.5.9.3、清bss段
	清除bss段是为了满足C语言的运行时要求（C语言要求显式初始化为0的全局变量，或者未显式初始化的全局变量的值为0，实际上C语言编译器就是通过清bss段来实现C语言的这个特性的）。一般情况下我们的程序是不需要负责清零bss段的（C语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的main函数之前运行，这段代码就负责清除bss）。但是在我们代码重定位了之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的bss，而未清除重定位地址处开头的那一份代码的bss，所以重定位之后需要自己去清除bss。
1.5.9.4、长跳转
	清理完bss段后重定位就结束了。然后当前的状况是：
	1、当前运行地址还在0xd0020010开头的（重定位前的）那一份代码中运行着。
	2、此时SRAM中已经有了2份代码，1份在d0020010开头，另一份在d0024000开头的位置。
	然后就要长跳转了。

1.5.10.SDRAM引入
1.5.10.1、SDRAM：Syncronized Dynamic Ramdam Access Memory，同步动态随机存储器
		  DDR：DDR就是DDR SDRAM，是SDRAM的升级版。（DDR：double rate，双倍速度的SDRAM）
		  DDR有好多代：DDR1 DDR2 DDR3 DDR4 LPDDR

1.5.10.2、SDRAM的特性（容量大、价格低、掉电易失性、随机读写、总线式访问）
	SDRAM/DDR都属于动态内存（相对于静态内存SRAM），都需要先运行一段初始化代码来初始化才能使用
	不像SRAM开机上电后就可以直接运行。
类似于SDRAM和SRAM的区别的，还有NorFlash和NandFlash（硬盘）这两个。
正是因为硬件本身特性有限制，所以才导致启动代码比较怪异、比较复杂。而我们研究裸机是为了研究uboot，在uboot中就充分利用了硬件的各种特性，处理了硬件复杂性。

1.5.10.3、SDRAM数据手册带读
SDRAM在系统中属于SoC外接设备（外部外设。以前说过随着半导体技术发展，很多东西都逐渐集成到SoC内部去了。现在还长期在外部的一般有：Flash、SDRAM/DDR、网卡芯片如DM9000、音频Codec。现在有一些高集成度的芯片也试图把这几个集成进去，做成真正的单芯片解决方案。）
SDRAM通过地址总线和数据总线接口（总线接口）与SoC通信。

开发板原理图上使用的是K4T1G164QQ，但是实际开发板上贴的不是这个，是另一款。但是这两款是完全兼容的，进行软件编程分析的时候完全可以参考K4T1G164QQ的文档。

全球做SDRAM的厂商不多，二线厂家做的产品参数都是向一线厂家（三星、KingSton）看齐，目的是兼容一线厂家的设计，然后让在意成本的厂商选择它的内存芯片替代一线厂家的内存芯片。SDRAM的这个市场特征就导致这个东西比较标准化，大部分时候细节参数官方（芯片原厂家）都会给你一个参考值。

K4T1G164QE：
K表示三星产品，4表示是DRAM，T表示产品号码，1G表示容量（1Gb，等于128MB，我们开发板X210上一共用了4片相同的内存，所以总容量是128×4=512MB）16表示单芯片是16位宽的，4表示是4bank，

三星官方的数据手册上其实没有芯片相关的参数设置信心，都是芯片选型与外观封装方面的信息，选型是给产品经理来看的，封装和电压等信息是给硬件工程师看的。软件工程师最关注的是工作参数信息，但是数据手册没有。

1.5.11.SDRAM初始化
1.5.11.1、原理图中SDRAM相关部分
S5PV210共有2个内存端口（就好象有2个内存插槽）。再结合查阅数据手册中内存映射部分，可知：两个内存端口分别叫DRAM0和DRAM1：
	DRAM0：内存地址范围：0x20000000～0x3FFFFFFF（512MB），对应引脚是Xm1xxxx
	DRAM1: 内存地址范围：0x40000000～0x7FFFFFFF（1024MB），对应引脚是Xm2xxxx
结论：
(1)整个210最多支持内存为1.5GB，如果给210更多的内存CPU就无法识别。
(2)210最多支持1.5GB内存，但是实际开发板不一定要这么多，譬如我们X210开发板就只有512MB内存，连接方法是在DRAM0端口分布256MB，在DRAM1端口分布了256MB。
(3)由2可知，X210开发板上内存合法地址是：0x20000000～0x2FFFFFFF（256MB） + 0x40000000～0x4FFFFFFF（256MB）。当板子上DDR初始化完成之后，这些地址都是可以使用的；如果使用了其他地址譬如0x30004000就是死路一条。

原理图中每个DDR端口都由3类总线构成：地址总线（Xmn_ADDR0~XMnADDR13共14根地址总线） + 控制总线（中间部分，自己看原理图） + 数据总线（Xmn_DATA0~XMnDATA31共32根数据线）
分析：从数据总线的位数可以看出，我们用的是32位的（物理）内存。

原理图中画出4片内存芯片的一页，可以看出：X210开发板共使用了4片内存（每片1Gb=128MB，共512MB），每片内存的数据总线都是16位的（单芯片是16位内存）。如何由16位内存得到32位内存呢？可以使用并联方法。在原理图上横向的2颗内存芯片就是并联连接的。并联时地址总线接法一样，但是数据总线要加起来。这样连接相当于在逻辑上可以把这2颗内存芯片看成是一个（这一个芯片是32位的，接在Xm1端口上）。
	
1.5.11.2、数据手册中SDRAM相关部分
看数据手册《NT5TU64M16GG-DDR2-1G-G-R18-Consumer》第10页的block diagram。这个框图是128Bb×8结构的，这里的8指的是8bank，每bank128Mbit。
210的DDR端口信号中有BA0～BA2，接在内存芯片的BA0～BA2上，这些引脚就是用来选择bank的。
每个bank内部有128Mb，通过row address（14位） + column address（10位）的方式来综合寻址。
一共能寻址的范围是：2的14次方+2的10次方 = 2的24次方。对应16MB（128Mbit）内存。

1.5.12.汇编初始化SDRAM详解1
1.5.12.1、初始化代码框架介绍（函数调用和返回、步骤等）
	SDRAM初始化使用一个函数sdram_asm_init，函数在sdram_init.S文件中实现，是一个汇编函数。
	强调：汇编实现的函数在返回时需要明确使用返回指令（mov pc, lr）
1.5.12.2、27步初始化DDR2
(1)首先，DDR初始化和SoC（准确说是和SoC中的DDR控制器）有关，也和开发板使用的DDR芯片有关，和开发板设计时DDR的连接方式也有关。
(2)S5PV210的DDR初始化步骤在SoC数据手册：1.2.1.3 DDR2这个章节。可知初始化DDR共需27个步骤。
(3)之前分析过X210的内存连接方式是：在DRAM0上连接256MB，在DRAM1上连接了256MB。所以初始化DRAM时分为2部分，第一部分初始化DRAM0，第二部分初始化DRAM1.
(4)我们的代码不是自己写的，这个代码来自于：第一，九鼎官方的uboot中；第二，参考了九鼎的裸机教程中对DDR的初始化；第三，有些参数是我根据自己理解修改过的。
1.5.12.3、设置IO端口驱动强度
因为DDR芯片和S5PV210之间是通过很多总线连接的，总线的物理表现就是很多个引脚，也就是说DDR芯片和S5PV210芯片是通过一些引脚连接的。DDR芯片工作时需要一定的驱动信号，这个驱动信号需要一定的电平水平才能抗干扰，所以需要设置这些引脚的驱动能力，使DDR正常工作。
DRAM控制器对应的引脚设置为驱动强度2X（我也不知道为什么是2X，什么时候设置成3X 4X?，这东西只能问DDR芯片厂商或者SoC厂商，我们一般是参考原厂给的代码）
1.5.12.4、DRAM port 时钟设置
从代码第128行到154行。主要是开启DLL（dram pll）然后等待锁存。
这段代码对应27步中的第2到第4步。

1.5.13.汇编初始化SDRAM详解2
1.5.13.1、DMC0_MEMCONTROL
	burst length=4，1chip，······  对应值是0x00202400
1.5.13.2、DMC0_MEMCONFIG_0
	DRAM0通道中memory chip0的参数设置寄存器
1.5.13.3、DMC0_MEMCONFIG_1
	DRAM0通道中memory chip1的参数设置寄存器
总结：我猜测（推论）：三星设置DRAM0通道，允许我们接2片256MB的内存，分别叫memory chip0和memory chip1，分别用这两个寄存器来设置它的参数。按照三星的设计，chip0的地址应该是0x20000000到0x2FFFFFFF，然后chip1的地址应该是0x30000000~0x3FFFFFFF.各自256MB。
但是我们X210开发板实际在DRAM0端口只接了256MB的内存，所以只用了chip0，没有使用chip1.（我们虽然是2片芯片，然后这两片是并联形成32位内存的，逻辑上只能算1片）。按照这个推论，DMC0_MEMCONFIG_0有用，而DMC0_MEMCONFIG_1无用，所以我直接给他了默认值。
1.5.13.4、DMC_DIRECTCMD
这个寄存器是个命令寄存器，我们210通过向这个寄存器写值来向DDR芯片发送命令（通过命令总线），这些命令应该都是用来配置DDR芯片工作参数。

总结：DDR配置过程比较复杂，基本上是按照DDR控制器的时序要求来做的，其中很多参数要结合DDR芯片本身的参数来定，还有些参数是时序参数，要去详细计算。所以DDR配置非常繁琐、细致、专业。所以我们对DDR初始化的态度就是：学会这种思路和方法，结合文档和代码能看懂，会算一些常见的参数即可。
1.5.13.5、重定位代码到SDRAM中
DRAM初始化之后，实际上重定位代码过程和之前重定位到SRAM中完全相同。

