ARM汇编指令集
（汇编）指令是CPU机器指令的助记符，经过编译后会得到一串10组成的机器码，可以由CPU读取执行。
（汇编）伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码

ARM汇编特点1：ldr/st架构，ldr/str组合用来是实现ARM CPU和内存数据交换
ARM汇编特点2：8种寻址方式
ARM汇编的8种寻址方式：
•	寄存器寻址			mov r1, r2    // 将r2寄存器中的值赋值给r1 
•	立即寻址			mov r0, #0xFF00  // 将立即数(就是普通的数)0xFF00(16位)赋值给r0
•	寄存器移位寻址		mov r0, r1, lsl #3  // 将r1左移3位(相当于r1*8)后再赋值给r0
•	寄存器间接寻址		ldr r1, [r2]  // 将r2类比成指针，以r2寄存器中的值为地址的内存中的数 
                   据赋给r1.
•	基址变址寻址		ldr r1, [r2, #4]  // 将r2类比成指针，以r2寄存器中的值+4为地址的内存
                   中的数据赋给r1.
•	多寄存器寻址		ldmia r1!, {r2-r7, r12}  // 以r1寄存器中的值为起始地址，依次读取后面八
                   个地址中的数据分别赋给r2到r7以及r8
•	堆栈寻址			stmfd sp!, {r2-r7, lr}  // 类似多寄存器寻址，区别是起始地址是在堆栈中

•	相对寻址		    reset:  // 名字+冒号叫做标号,标记标号后面一句指令的地址,类似函数名，
                   用法举例：b reset  // 跳到reset标号处执行

ARM汇编特点3：指令后缀
•	同一指令经常附带不同后缀，变成不同的指令。经常使用的后缀有：
•	B（byte）功能不变，操作长度变为8位
•	H（half word）功能不变，长度变为16位
•	S（signed）功能不变，操作数变为有符号
如 ldr ldrb ldrh ldrsb ldrsh
•	S（S标志）功能不变，影响CPSR(程序状态寄存器中的NZCV)标志位
•	如 mov和movs		movs r0, #0

ARM汇编特点4：条件后缀(相当于c语言的if条件语句)
 
举例：mov r0， r1  // 相当于C语言中的r0 = r1；
moveq r0, r1 //如果eq后缀成立，则直接执行mov r0， r1 ,如果eq不成立， 则不执行mov r0， r1 , 相当于C语言if(eq){r0 = r1}

ARM汇编特点5：多级指令流水线
         
注：寄存器寻址和内存寻址的区别：寄存器寻址是靠寄存器名字去寻找的，而内存寻址是地址去寻找的

常用ARM汇编指令1：数据处理指令
•	数据传输指令	mov mvn
mov r1, r0		@两个寄存器之间数据传递
mov r1, #0xff	@ 将立即数赋值给寄存器
mvn和mov用法一样，区别是mov是原封不动的传递，而mvn是按位取反后传递
按位取反的含义：
譬如r1 = 0x000000ff，然后mov r0, r1 后，r0 = 0xff			但是我mvn r0, r1后，r0=0xffffff00
•	算术指令	
	add  加法 
		add     r0, r1, r2              ; r0 = r1 + r2
  		add     r0, r1, #256            ; r0 = r1 + 256
 	 add     r0, r2, r3,lsl#1        ; r0 = r2 + (r3 << 1)
sub  减法
	sub     r0, r1, r2              ; r0 = r1 - r2
sub     r0, r1, #256            ; r0 = r1 – 256
sub     r0, r2, r3,lsl#1        ; r0 = r2 - (r3 << 1)
rsb   反向减法
  	rsb     r0, r1, r2              ; r0 = r2 - r1
            rsb     r0, r1, #256            ; r0 = 256 - r1
            rsb     r0, r2, r3,lsl#1        ; r0 = (r3 << 1) - r2
adc  带进位的加法
adc 将把两个操作数加起来，并把结果放置到目的寄存器中。它使用一个进位标志位，这样就
可以做比 32 位大的加法。下列例子将加两个 128 位的数。
  	adds    r0, r4, r8              ; 加低端的字
 	   adcs    r1, r5, r9              ; 加下一个字，带进位
	   adcs    r2, r6, r10             ; 加第三个字，带进位
	   adcs    r3, r7, r11             ; 加高端的字，带进位
如果如果要做这样的加法，不要忘记设置 S 后缀来更改进位标志。
sbc  带借位的减法
		sbc做两个操作数的减法，把结果放置到目的寄存器中。它使用进位标志来表示借位，这样就
可以做大于 32 位的减法。SUB 和 SBC 生成进位标志的方式不同于常规，如果需要借位
则清除进位标志。所以，指令要对进位标志进行一个非操作 - 在指令执行期间自动的反转此
位。
rsc  带借位的反向减法
		同于 SBC，但倒换了两个操作数的前后位置。		
•	逻辑指令		
and  逻辑与
add    r0, r0, #3           ; r0 = r0 & 0x4(2的3-1次方) 只保留位2的值
orr   逻辑或
orr     r0, r0, #3           ; r0 = r0 | 0x4(2的3-1次方) 将位2置1
eor   逻辑异或   // 逻辑异或的作用是当两个操作数同为真时，返回结果为假，否则为真
bic   位清零
	bic    r0, r0, #%1011     ; 清除 r0 中的位 0、1、和 3。保持其余的不变。(跟c语言
	中的清理&的使用方法相反)
•	比较指令	
cmp		cmp  r0, r1   等价于 sub r2, r0, r1  (r2 = r0 - r1)  若相等，则cpsr的相应标志位置1
cmn		cmn  r0, r1   等价于 add r0, r1
tst		tst    r0, #0xf	 @测试r0的bit0～bit3是否全为0
teq		teq   r0, r1		 @对r0、r1进行异或
比较指令用来比较2个寄存器中的数，不产生运算结果。比较指令是用来影响cpsr的标志位的
注意：比较指令不用后加s后缀就可以影响cpsr中的标志位。
•	乘法指令（基本用不到）		
mvl 
mla 
umull 
umlal 
smull 
smlal
•	前导零计数（基本用不到）		clz  @看一个数前面有多少个0

常用ARM汇编指令2：cpsr访问指令
CPSR寄存器比较特殊，需要专门的指令访问，这就是mrs和msr。
mrs用来读psr，msr用来写psr
举例： mrs		r0, cpsr
		  bic 		r0, r0, #0xd3
		  msr 		cpsr, r0
		  以上为读写cpsr寄存器，等价于cpsr_c, #0xd3
cpsr和spsr的区别和联系：cpsr是程序状态寄存器，整个SoC中只有1个；而spsr有5个，分别在5种异常模式下，作用是当从普通模式进入异常模式时，用来保存之前普通模式下的cpsr的，以在返回普通模式时恢复原来的cpsr。

常用ARM汇编指令3：跳转（分支）指令
•	b 直接跳转（就没打开算返回）
•	bl branch and link，跳转前把返回地址放入lr中，以便返回，以便用于函数调用
•	bx跳转同时切换到ARM模式，一般用于异常处理的跳转。

常用ARM汇编指令4：访存指令
•	单个字/半字/字节访问 ldr/str
ldr  // load register 将内存内容加载到通用寄存器中
str  // store register 将寄存器中内容存入到数据空间
•	多字批量访问  ldm/stm
•	swp寄存器和内存互换
•	swp r1, r2, [r0]  ；先将[r0]（r0为地址的内存中的数）赋给r1，再将r2放到[r0]中
•	swp r1, r1, [r0]  ；r1、[r0]互换

常用ARM指令5：软中断指令
•	swi（software interrupt）
软中断指令用来实现操作系统中系统调用

ARM汇编中的立即数
•	ARM指令都是32位，除了指令标记和操作标记外，本身只能附带很少位数的立即数。因此立即数有合法和非法之分。
•	合法立即数：经过任意位数的移位后非零部分可以用8位表示的即为合法立即数
合法立即数： 0x000000ff	0x00ff0000 0xf000000f 
非法立即数： 0x000001ff

协处理器cp15操作指令
•	mrc用于读取CP15中的寄存器
•	mcr用于写入CP15中的寄存器

为什么需要多寄存器访问指令
•	ldr/str每周期只能访问4字节内存，如果需要批量读取、写入内存时太慢，解决方案是stm/ldm
ldm (load register mutiple)
stm (store register mutiple)
举例：
stmia	sp, {r0 - r12}
将r0存入sp指向的内存处（假设为0x30001000）；然后地址+4（即指向0x30001004），将r1存入该地址；然后地址再+4（指向0x30001008），将r2存入该地址······直到r12内容放入（0x3001030），指令完成。
一个访存周期同时完成13个寄存器的读写

栈的处理
8种后缀
•	ia（increment after）先传输，再地址+4
•	ib（increment before）先地址+4，再传输
•	da（decrement after）先传输，再地址-4
•	db（decrement before）先地址-4，再传输
•	fd（full descenfing）满递减堆栈
•	ed（empty decending）空递减堆栈
•	fa（full ascending） 满递增堆栈
•	ea（empty ascending）空递增堆栈四
谨记：操作栈时使用相同的后缀就不会出错，不管是满栈还是空栈、增栈还是减栈

四种栈
•	空栈：栈指针指向空位，每次存入时可以直接存入然后栈指针移动一格；而取出时需要先移动一格才能取出
•	满栈：栈指针指向栈中最后一格数据，每次存入时需要先移动栈指针一格再存入；取出时可以直接取出，然后再移动栈指针
•	增栈：栈指针移动时向地址增加的方向移动的栈
•	减栈：栈指针移动时向地址减小的方向移动的栈

！的作用
•	ldmia	r0, {r2 - r3}
•	ldmia	r0！, {r2 - r3}
感叹号的作用就是r0的值在ldm过程中发生的增加或者减少最后写回到r0去，也就是说ldm时会改变r0的值。
^的作用
•	ldmfd	sp!, {r0 - r6, pc}
•	ldmfd	sp!, {r0 - r6, pc}^
^的作用：在目标寄存器中有pc时，会同时将spsr写入到cpsr，一般用于从异常模式返回

ARM汇编伪指令
•	伪指令不是指令，伪指令和指令的根本区别是经过编译后会不会生成机器码。
•	伪指令的意义在于指导编译过程。
•	伪指令是和具体的编译器相关的，我们使用gnu工具链，因此学习gnu环境下的汇编伪指令。

gnu汇编中的一些符号
•	@ 用来做注释。可以在行首也可以在代码后面同一行直接跟，和C语言中//类似
•	# 做注释，一般放在行首，表示这一行都是注释而不是代码。
•	：以冒号结尾的是标号
•	.  点号在gnu汇编中表示当前指令的地址
•	# 立即数前面要加#或$，表示这是个立即数

常用gnu伪指令
•	.global _start	@ 给_start外部链接属性，一般为了在别的文件中引用这个符号，类似extern _start
•	.section .text	@ 指定当前段为代码段  段名为“.test”  段：后面说
•	.ascii .byte .short .long .word 
.ascii "string..."				定义一个ascii字符串string
•	.quad .float .string @ 定义数据，类似C语言的int、float等  (不常用)
•	.align 4			@ 以16字节对齐
balign/.balignw/.balignl	字节/2字节/4字节填充
注意.align数字是2的n次方，而.balign数字是直接数字
•	.balignl 16 0xabcdefgh 	@ 16字节对齐填充
•	.equ			@ 类似于C中宏定义
偶尔会用到的gnu伪指令
•	.end			@标识文件结束
•	.include			@ 头文件包含
•	.arm / .code32	@声明以下为arm指令
•	.thumb / .code16	@声明以下为thubm指令
最重要的几个伪指令
•	ldr	大范围的地址加载指令
•	adr	小范围的地址加载指令
•	adrl	中等范围的地址加载指令
•	nop	空操作
•	ARM中有一个ldr指令，还有一个ldr伪指令
•	一般都使用ldr伪指令而不用ldr指令
adr与ldr
•	adr编译时会被1条sub或add指令替代，而ldr编译时会被一条mov指令替代或者文字池方式处理；
•	adr总是以PC为基准来表示地址，因此指令本身和运行地址有关，可以用来检测程序当前的运行地址在哪里
•	ldr加载的地址和链接时给定的地址有关，由链接脚本决定。

宏定义
.macro macroname
宏体
.endm

① while(1);

② flag:
	 b flag

③ b .
// 以上都为死循环
	
IRQ_STACK_START:
	.word	0x0badc0de
等价于 unsigned int IRQ_STACK_START = 0x0badc0de;

.align 4	@ 16字节对齐
.align 2	@ 4字节对齐

.balignl 16, 0xdeadbeef		@ 对齐 + 填充  
b表示位填充；align表示要对齐；l表示long，以4字节为单位填充；16表示16字节对齐；0xdeadbeef是用来填充的原料。

0x00000008:		.balignl 16, 0xdeadbeef
0x0000000c		0xdeadbeef  // 填充
0x00000010: 	下一条指令
ldr指令：		ldr r0, #0xff
伪指令：		ldr r0, =0xfffl		@涉及到合法/非法立即数，涉及到ARM文字池

adr和ldr的差别：ldr加载的地址在链接时确定，而adr加载的地址在运行时确定；所以我们可以通过adr和ldr加载的地址比较来判断当前程序是否在链接时指定的地址运行。
